---
title: "Locale sensitive functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Locale sensitive functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r}
#| include: FALSE
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(stringr)
```

stringr provides a number of locale-sensitive functions, i.e. functions whose behaviour depends on your locale, of which your language is a very important part. stringr defaults to English, `locale = "en"`, but you can override by providing a different `locale` specified by a lower-case language abbreviation, optionally followed by an underscore (_) and an upper-case region identifier. For example, "en" is English, "en_GB" is British English, and "en_US" is American English. For a list of language codes see [Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639_language_codes) and to see which are supported in stringr, run `stringi::stri_locale_list()`.

There are three main types of function that vary based on locale:

1. Case conversion
2. Sorting and ordering
3. String comparison

## Case conversion

Most languages that use the Latin alphabet (like English) have upper and lower case, but the rules for converting between the two aren't always the same. For example, Turkish has two forms of the letter "I", dotted and dotless:

```{r}
str_to_upper(c("i", "ı"))
str_to_upper(c("i", "ı"), locale = "tr")

str_to_lower(c("İ", "I"), locale = "tr")
```

Another example is Dutch, where "ij" is a digraph treated as a single letter. This means that `string_to_title()` will incorrectly capitalize it unless you use a Dutch locale:

```{r}
#| warning: false
dutch_words <- c("ijsvrij yoghurt", "ijmuiden", "bij elkaar")

str_to_title(dutch_words)
str_to_title(dutch_words, locale = "nl")
```

(Note that `str_to_title()` handles character-level locale differences but it doesn't implement locale-specific rules about which words not to capitalize. Fortunately, title case appears to be concept that applies primarily to English.)

Case-sensitive string comparison also comes up in `str_equal()`/`str_unique()` and in pattern matching functions. To take advantage of locale-specific case matching, supply `locale` to `str_equal()`/`str_unique()` and use `coll()` instead of `fixed()` in pattern matching functions.

```{r}
turkish_names <- c("İpek", "Işık", "İbrahim")
search_name <- "ipek"

# incorrect
str_equal(turkish_names, search_name, ignore_case = TRUE)
str_detect(turkish_names, fixed(search_name, ignore_case = TRUE))

# correct
str_equal(turkish_names, search_name, ignore_case = TRUE, locale = "tr")
str_detect(turkish_names, coll(search_name, ignore_case = TRUE, locale = "tr"))
```

## Sorting and ordering

Alphabetical order can vary dramatically across languages. For example, Lithuanian places 'y' between 'i' and 'k' and Czech treats "ch" as a single compound letter that sorts after all other 'h' words. 

```{r}
czech_words <- c("had", "chata", "hrad", "chůze")
lithuanian_words <- c("ąžuolas", "ėglė", "šuo", "yra", "žuvis")

# incorrect
str_sort(czech_words)
str_sort(lithuanian_words)

# correct
str_sort(czech_words, locale = "cs")
str_sort(lithuanian_words, locale = "lt")
```

## String comparison

Letters that appear the same can have different Unicode representations:

```{r}
name1 <- "José"       # precomposed é (single character)
name2 <- "Jose\u0301" # e + combining acute accent (two characters)
str_view(c(name1, name2))
```

They look identical but `==` says they are different:

```{r}
name1 == name2
```

Fortunately, stringr's comparison functions correctly handle these differences:

```{r}
str_equal(name1, name2)
str_unique(c(name1, name2))
```
